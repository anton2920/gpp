package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	stdstrings "strings"

	"github.com/anton2920/gofa/strings"
)

type Result struct {
	*File

	Buffer bytes.Buffer
	Tabs   int

	DoImports Imports
	Constants []Constant
}

const GeneratedSuffix = "_gpp"

func (r *Result) AddImport(s string) {
	var found *Import
	for i := 0; i < len(r.Imports); i++ {
		if (r.Imports[i].QualifiedName == s) || (strings.EndsWith(r.Imports[i].Path, s)) {
			found = &r.Imports[i]
			break
		}
	}

	var insert Import
	if found == nil {
		insert.Path = s
	} else {
		insert = *found
	}

	for _, di := range r.DoImports {
		if ((len(insert.QualifiedName) > 0) && (insert.QualifiedName == di.QualifiedName)) || (insert.Path == di.Path) {
			return
		}
	}
	r.DoImports = append(r.DoImports, insert)
}

func (r *Result) AddImports(is []string) {
	for _, i := range is {
		r.AddImport(i)
	}
}

func (r *Result) AddConstant(name string, value string) Constant {
	constant := Constant{Name: name, Value: value}
	if len(constant.Value) > 0 {
		r.Constants = append(r.Constants, constant)
	}
	return constant
}

func (r *Result) Dump(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	var total int64

	if len(r.Package) == 0 {
		r.Package = "main"
	}

	fmt.Fprintf(&buf, "/* File generated by \"gpp %s\"; DO NOT EDIT. */\n\n", stdstrings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "package %s\n", r.Package)

	sort.Sort(r.DoImports)

	var newline bool
	if len(r.DoImports) > 0 {
		fmt.Fprintf(&buf, "\nimport ")
		if len(r.DoImports) > 1 {
			buf.WriteString("(\n")
		}
		for i := 0; i < len(r.DoImports); i++ {
			imp := &r.DoImports[i]

			if len(r.DoImports) > 1 {
				if (!newline) && (strings.FindChar(imp.Path, '/') != -1) {
					if i > 0 {
						buf.WriteRune('\n')
					}
					newline = true
				}
				buf.WriteRune('\t')
			}
			if len(imp.QualifiedName) > 0 {
				fmt.Fprintf(&buf, "%s ", imp.QualifiedName)
			}
			fmt.Fprintf(&buf, "\"%s\"\n", imp.Path)
		}
		if len(r.DoImports) > 1 {
			buf.WriteString(")\n")
		}
	}

	if len(r.Constants) > 0 {
		maxLen := len(r.Constants[0].Name)
		for i := 1; i < len(r.Constants); i++ {
			constant := &r.Constants[i]
			if len(constant.Name) > maxLen {
				maxLen = len(constant.Name)
			}
		}

		buf.WriteString("\nconst (\n")
		for i := 0; i < len(r.Constants); i++ {
			constant := &r.Constants[i]
			buf.WriteRune('\t')
			buf.WriteString(constant.Name)
			for j := 0; j < maxLen-len(constant.Name); j++ {
				buf.WriteRune(' ')
			}
			buf.WriteString(" = ")
			buf.WriteString(constant.Value)
			buf.WriteRune('\n')
		}
		buf.WriteString(")\n")
	}

	n, err := io.Copy(w, bytes.NewReader(buf.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	n, err = io.Copy(w, bytes.NewReader(r.Buffer.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	return total, nil
}

func (r *Result) ShouldDump() bool {
	return r.Buffer.Len() != 0
}

func (r *Result) DoTabs() {
	for i := 0; i < r.Tabs; i++ {
		r.Buffer.WriteRune('\t')
	}
}

func (r *Result) Printf(format string, args ...interface{}) {
	r.DoTabs()
	fmt.Fprintf(&r.Buffer, format, args...)
	r.Buffer.WriteRune('\n')
}

func (r *Result) Bytes(b []byte) {
	r.DoTabs()
	r.Buffer.Write(b)
}

func (r *Result) Line(l string) {
	r.String(l)
	r.Buffer.WriteRune('\n')
}

func (r *Result) Rune(c rune) {
	r.DoTabs()
	r.Buffer.WriteRune(c)
}

func (r *Result) String(s string) {
	r.DoTabs()
	r.Buffer.WriteString(s)
}

func GeneratedName(filename string) string {
	ext := filepath.Ext(filename)
	base := filename[:len(filename)-len(ext)]
	return base + GeneratedSuffix + ext
}
