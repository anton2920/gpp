package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	stdstrings "strings"

	"github.com/anton2920/gofa/strings"
)

type Result struct {
	*File

	Buffer bytes.Buffer
	Tabs   int

	DoImports Imports
}

const GeneratedSuffix = "_gpp"

func (r *Result) AddImport(s string) {
	var found *Import
	for i := 0; i < len(r.Imports); i++ {
		if (r.Imports[i].QualifiedName == s) || (strings.EndsWith(r.Imports[i].Path, s)) {
			found = &r.Imports[i]
			break
		}
	}

	var insert Import
	if found == nil {
		insert.Path = s
	} else {
		insert = *found
	}

	for _, di := range r.DoImports {
		if ((len(insert.QualifiedName) > 0) && (insert.QualifiedName == di.QualifiedName)) || (insert.Path == di.Path) {
			return
		}
	}
	r.DoImports = append(r.DoImports, insert)
}

func (r *Result) Dump(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	var total int64

	if len(r.Package) == 0 {
		r.Package = "main"
	}

	fmt.Fprintf(&buf, "/* File generated by \"gpp %s\"; DO NOT EDIT. */\n\n", stdstrings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "package %s\n", r.Package)

	sort.Sort(r.DoImports)

	var newline bool
	if len(r.DoImports) > 0 {
		fmt.Fprintf(&buf, "\nimport ")
		if len(r.DoImports) > 1 {
			buf.WriteString("(\n")
		}
		for i := 0; i < len(r.DoImports); i++ {
			imp := &r.DoImports[i]

			if len(r.DoImports) > 1 {
				if (!newline) && (strings.FindChar(imp.Path, '/') != -1) {
					buf.WriteRune('\n')
					newline = true
				}
				buf.WriteRune('\t')
			}
			if len(imp.QualifiedName) > 0 {
				fmt.Fprintf(&buf, "%s ", imp.QualifiedName)
			}
			fmt.Fprintf(&buf, "\"%s\"\n", imp.Path)
		}
		if len(r.DoImports) > 1 {
			buf.WriteString(")\n")
		}
	}

	n, err := io.Copy(w, bytes.NewReader(buf.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	n, err = io.Copy(w, bytes.NewReader(r.Buffer.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	return total, nil
}

func (r *Result) ShouldDump() bool {
	return r.Buffer.Len() != 0
}

func (r *Result) DoTabs() {
	for i := 0; i < r.Tabs; i++ {
		r.Buffer.WriteRune('\t')
	}
}

func (r *Result) WithoutTabs() *Result {
	var newr Result
	newr = *r
	newr.Tabs = 0
	return &newr
}

func (r *Result) Printf(format string, args ...interface{}) {
	r.DoTabs()
	fmt.Fprintf(&r.Buffer, format, args...)
}

func (r *Result) Printfln(format string, args ...interface{}) {
	r.DoTabs()
	r.WithoutTabs().Rune('\n')
}

func (r *Result) Bytes(b []byte) {
	r.DoTabs()
	r.Buffer.Write(b)
}

func (r *Result) Line(l string) {
	r.String(l)
	r.WithoutTabs().Rune('\n')
}

func (r *Result) Rune(c rune) {
	r.DoTabs()
	r.Buffer.WriteRune(c)
}

func (r *Result) String(s string) {
	r.DoTabs()
	r.Buffer.WriteString(s)
}

func GeneratedName(filename string) string {
	ext := filepath.Ext(filename)
	base := filename[:len(filename)-len(ext)]
	return base + GeneratedSuffix + ext
}
