package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	stdstrings "strings"

	"github.com/anton2920/gofa/strings"
)

type Result struct {
	File *File

	Buffer *bytes.Buffer
	Tabs   int

	DoImports Imports
	Constants []Constant

	withoutTabs *Result
}

const GeneratedSuffix = "_gpp"

func (r *Result) AddImport(s string) {
	if len(s) == 0 {
		return
	}

	var found *Import
	for i := 0; i < len(r.File.Imports); i++ {
		if (r.File.Imports[i].QualifiedName == s) || (strings.EndsWith(r.File.Imports[i].Path, s)) {
			found = &r.File.Imports[i]
			break
		}
	}

	var insert Import
	if found == nil {
		insert.Path = s
	} else {
		insert = *found
	}

	for _, di := range r.DoImports {
		if ((len(insert.QualifiedName) > 0) && (insert.QualifiedName == di.QualifiedName)) || (insert.Path == di.Path) || (filepath.Base(insert.Path) == filepath.Base(di.Path)) {
			return
		}
	}
	r.DoImports = append(r.DoImports, insert)
}

func (r *Result) AddConstant(name string, value string) Constant {
	constant := Constant{Name: name, Value: value}
	if len(constant.Value) > 0 {
		for i := 0; i < len(r.Constants); i++ {
			c := &r.Constants[i]
			if constant.Name == c.Name {
				if constant.Value != c.Value {
					Warnf("overwriting constant %q from value %q to %q", c.Name, c.Value, value)
					c.Value = value
				}
				return constant
			}
		}
		r.Constants = append(r.Constants, constant)
	}
	return constant
}

func (r *Result) Backspace(ns ...int) *Result {
	if len(ns) > 1 {
		panic("(*Result).Backspace accepts either 0 or 1 numbers")
	}

	n := 1
	if len(ns) == 1 {
		n = ns[0]
	}

	r.Buffer.Truncate(r.Buffer.Len() - n)
	return r
}

func (r *Result) RemoveLastNewline() *Result {
	if strings.EndsWith(r.Buffer.String(), "\n\n") {
		r.Backspace()
	}
	return r
}

func (r *Result) RemoveEmptyStringBlock() *Result {
	var ntabs string
	for i := 0; i < r.Tabs; i++ {
		ntabs += "\t"
	}
	suffix := ntabs + "h.String(``)\n"
	if strings.EndsWith(r.Buffer.String(), suffix) {
		r.Backspace(len(suffix))
	}
	if r.Buffer.String()[:r.Buffer.Len()-1] != "\n" {
		r.Buffer.WriteRune('\n')
	}
	return r.RemoveLastNewline()
}

func (r *Result) Dump(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	var total int64

	if len(r.File.Package) == 0 {
		r.File.Package = "main"
	}

	fmt.Fprintf(&buf, "/* File generated by \"gpp %s\"; DO NOT EDIT. */\n\n", stdstrings.Join(os.Args[1:], " "))
	if filepath.Ext(r.File.Name) != ".gox" {
		fmt.Fprintf(&buf, "package %s\n", r.File.Package)
	}

	sort.Sort(r.DoImports)

	var newline bool
	if len(r.DoImports) > 0 {
		fmt.Fprintf(&buf, "\nimport ")
		if len(r.DoImports) > 1 {
			buf.WriteString("(\n")
		}
		for i := 0; i < len(r.DoImports); i++ {
			imp := &r.DoImports[i]

			if len(r.DoImports) > 1 {
				if (!newline) && (strings.FindChar(imp.Path, '/') != -1) {
					if i > 0 {
						buf.WriteRune('\n')
					}
					newline = true
				}
				buf.WriteRune('\t')
			}
			if len(imp.QualifiedName) > 0 {
				fmt.Fprintf(&buf, "%s ", imp.QualifiedName)
			}
			fmt.Fprintf(&buf, "\"%s\"\n", imp.Path)
		}
		if len(r.DoImports) > 1 {
			buf.WriteString(")\n")
		}
	}

	if len(r.Constants) > 0 {
		maxLen := len(r.Constants[0].Name)
		for i := 1; i < len(r.Constants); i++ {
			constant := &r.Constants[i]
			if len(constant.Name) > maxLen {
				maxLen = len(constant.Name)
			}
		}

		buf.WriteString("\nconst (\n")
		for i := 0; i < len(r.Constants); i++ {
			constant := &r.Constants[i]
			buf.WriteRune('\t')
			buf.WriteString(constant.Name)
			for j := 0; j < maxLen-len(constant.Name); j++ {
				buf.WriteRune(' ')
			}
			buf.WriteString(" = ")
			buf.WriteString(constant.Value)
			buf.WriteRune('\n')
		}
		buf.WriteString(")\n")
	}

	n, err := io.Copy(w, bytes.NewReader(buf.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	n, err = io.Copy(w, bytes.NewReader(r.Buffer.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	return total, nil
}

func (r *Result) ShouldDump() bool {
	return r.Buffer.Len() != 0
}

func (r *Result) DoTabs(s string) {
	if len(s) > 0 {
		if s == "}" {
			r.Tabs--
		}
		for i := 0; i < r.Tabs; i++ {
			r.Buffer.WriteRune('\t')
		}
		if ((strings.EndsWith(s, "{")) || (strings.EndsWith(s, ":"))) && (strings.FindSubstring(s, "switch") == -1) {
			r.Tabs++
		}
	}
}

func (r *Result) Printf(format string, args ...interface{}) *Result {
	r.DoTabs(format)
	fmt.Fprintf(r.Buffer, format, args...)
	r.Buffer.WriteRune('\n')
	return r
}

func (r *Result) Line(l string) *Result {
	r.DoTabs(l)
	r.Buffer.WriteString(l)
	r.Buffer.WriteRune('\n')
	return r
}

func (r *Result) Rune(c rune) *Result {
	r.DoTabs("")
	r.Buffer.WriteRune(c)
	return r
}

func (r *Result) WithoutTabs() *Result {
	if r.withoutTabs != nil {
		return r.withoutTabs
	}
	r.withoutTabs = &Result{File: r.File, Buffer: r.Buffer, DoImports: r.DoImports, Constants: r.Constants}
	return r.withoutTabs
}

func GeneratedName(filename string) string {
	ext := filepath.Ext(filename)
	base := filename[:len(filename)-len(ext)]
	if ext == ".gox" {
		return base + "_gox.go"
	} else {
		return base + GeneratedSuffix + ext
	}
}
