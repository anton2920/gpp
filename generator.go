package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

type Generator struct {
	Buffer bytes.Buffer

	Package string
	Imports Imports
}

const (
	JSONGeneratorPrefix = "JSONSerialize"
)

func (g *Generator) AddImports(imps ...Import) {
	for i := 0; i < len(imps); i++ {
		imp := imps[i]

		var found bool
		for j := 0; j < len(g.Imports); j++ {
			if imp.Path == g.Imports[j].Path {
				found = true
				break
			}
		}

		if !found {
			g.Imports = append(g.Imports, imp)
		}
	}
}

func (g *Generator) Dump(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	var total int64

	fmt.Fprintf(&buf, "/* File generated by \"gpp %s\"; DO NOT EDIT. */\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "package %s\n", g.Package)

	sort.Sort(g.Imports)

	if len(g.Imports) > 0 {
		fmt.Fprintf(&buf, "\nimport ")
		if len(g.Imports) > 1 {
			buf.WriteString("(\n")
		}
		for i := 0; i < len(g.Imports); i++ {
			imp := &g.Imports[i]

			if len(g.Imports) > 1 {
				buf.WriteRune('\t')
			}
			if len(imp.QualifiedName) > 0 {
				fmt.Fprintf(&buf, "%s ", imp.QualifiedName)
			}
			fmt.Fprintf(&buf, "\"%s\"\n", imp.Path)
		}
		if len(g.Imports) > 1 {
			buf.WriteString(")\n")
		}
	}

	n, err := io.Copy(w, bytes.NewReader(buf.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	n, err = io.Copy(w, bytes.NewReader(g.Buffer.Bytes()))
	if err != nil {
		return 0, err
	}
	total += n

	return total, nil
}

func (g *Generator) Printf(format string, args ...interface{}) (int, error) {
	return fmt.Fprintf(&g.Buffer, format, args...)
}

func (g *Generator) ShouldDump() bool {
	return g.Buffer.Len() != 0
}

func (g *Generator) Write(b []byte) (int, error) {
	return g.Buffer.Write(b)
}

func (g *Generator) WriteRune(r rune) (int, error) {
	return g.Buffer.WriteRune(r)
}

func (g *Generator) WriteString(s string) (int, error) {
	return g.Buffer.WriteString(s)
}

func GeneratedName(filename string) string {
	ext := filepath.Ext(filename)
	base := filename[:len(filename)-len(ext)]
	return base + "_gpp" + ext
}

/* NOTE(anton2920): this supports only ASCII. */
func VariableName(typeName string, array bool) string {
	var lastUpper int
	for i := 0; i < len(typeName); i++ {
		if unicode.IsUpper(rune(typeName[i])) {
			lastUpper = i
		}
	}

	var suffix string
	if array {
		suffix = "s"
	}

	return fmt.Sprintf("%c%s%s", unicode.ToLower(rune(typeName[lastUpper])), typeName[lastUpper+1:], suffix)
}
